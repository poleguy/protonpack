	;ESM rs232 32 bit register controller with dump capability
	;
	; Commands: (All hex parameters support variable length - leading zeros optional)
	; r [addr32] -- read a 32 bit address
	;               reads and displays the 32-bit value at the specified address
	;               address can be 1-8 hex digits, leading zeros optional
	;               Example: r 100 (same as r 00000100)
	;
	; w [addr32] [data32] -- write data to a 32bit address
	;                        writes a 32-bit data value to the specified address
	;                        address and data can be 1-8 hex digits each, leading zeros optional
	;                        Example: w 100 BEEF (same as w 00000100 0000BEEF)
	;
	; rd [addr8] -- read an 8 bit port/register address
	;               reads and displays the 8-bit value from the specified port
	;               address can be 1-2 hex digits, leading zeros optional
	;               Example: rd F (same as rd 0F)
	;
	; wr [addr8] [data8] -- write data to an 8bit port/register address
	;                       writes an 8-bit data value to the specified port
	;                       address and data can be 1-2 hex digits each, leading zeros optional
	;                       Example: wr 1F A (same as wr 1F 0A)
	;
	; d [start addr32] [end addr32] [repeat counter32] -- dump memory range in ASCII hex
	;                                                     dumps memory from start to end address
	;                                                     repeat counter is optional (defaults to 1)
	;                                                     all parameters can be 1-8 hex digits, leading zeros optional
	;                                                     output format: CRLF + 2 hex digits per byte
	;                                                     Example: d 0 FF (same as d 00000000 000000FF 1)
	;
	; b [start addr32] [end addr32] [repeat counter32] -- binary dump memory range
	;                                                     same as 'd' but outputs raw binary data instead of ASCII hex
	;                                                     no CRLF between words, just raw bytes
	;                                                     repeat counter is optional (defaults to 1)
	;                                                     all parameters can be 1-8 hex digits, leading zeros optional
	;                                                     Example: b 0 1FF (same as b 00000000 000001FF 1)
	;
	; wf -- write file mode
	;       enters mode to receive binary data and write to 32-bit FIFO
	;       stays in mode until FIFO full flag is set
	;
	; rf -- read file mode
	;       enters mode to read from 32-bit FIFO and transmit via UART
	;       stays in mode until FIFO empty flag is set

	;USB Core/MPU constant declarations
	CONSTANT	UARTFIFO, 00		;output/input
	CONSTANT	unused1,01
	CONSTANT	unused2,02
	CONSTANT	interrupt,03		;output/input
	CONSTANT	unused3,04
	CONSTANT	unused4,05
	CONSTANT	offset,06		;output
	CONSTANT	status,07		;input
	
	CONSTANT	dt_rst,08		;single bit out
	CONSTANT	ep0out_rst,09		;single bit out
	CONSTANT	ep0in_rst,0a		;single bit out
	CONSTANT	ep1out_rst,0b		;single bit out
	CONSTANT	ep1in_rst,0c		;single bit out


	;SDRAM controller constant declarations
	CONSTANT	sdramrdwr,19		;write data to the SDRAM, uses write/read strobe 


	;32 bit register control
	CONSTANT	addr_3,10		;fifo memory (31:24)
	CONSTANT	addr_2,11		;fifo memory (23:16)
	CONSTANT	addr_1,12		;fifo memory (15:8)
	CONSTANT	addr_0,13		;fifo memory (7:0) (a write to this causes a 32 bit read to the data registers)
	CONSTANT	data_3,14		;fifo memory (31:24)
	CONSTANT	data_2,15		;fifo memory (23:16)
	CONSTANT	data_1,16		;fifo memory (15:8)
	CONSTANT	data_0,17		;fifo memory (7:0) (a write to this causes a 32 bit write)


	;GSM modulator/Upconverter control (20's)
	CONSTANT	freq_4,20		;frequency control word (31:24)
	CONSTANT	freq_3,21		;frequency control word (23:16)
	CONSTANT	freq_2,22		;frequency control word (15:8)
	CONSTANT	freq_1,23		;frequency control word (7:0)
	CONSTANT	amp_2,24		;amplitude control word (15:8)
	CONSTANT	amp_1,25		;amplitude control word (7:0)
	CONSTANT	symbol,26		;symbol output for IQ modulator 3bits for 8-PSK

	CONSTANT	ts_rst,29		;reset at beginning of new timeslot
	CONSTANT	frm_rst,2a		;reset at beginning of new TDMA frame
	CONSTANT	clk1x_rst,2b		;timeslot clock reset flag

	CONSTANT	ramptrig,2c		;trigger to start ramp
	CONSTANT	pn_inc,2d		;increment pn generator
	CONSTANT	rom_inc,2e		;increment rom address/location



	;Misc. constant declarations
	CONSTANT	gpio1,10		;(7:4)capture size output/(1:0)LED output
	CONSTANT	gpio2,11		;(7)datain_cntrl reset/(6:4) datain_cntrl select
	CONSTANT	gpio3,12		;dll144lck,dllextlck,0,0,0,0,0,dip1
	CONSTANT	rs232,1f		;rs232 debug port

	namereg s00,s0
	namereg s01,s1
	namereg s02,s2
	namereg s03,s3
	namereg s04,s4
	namereg s05,s5
	namereg s06,s6
	namereg s07,s7
	namereg s08,s8
	namereg s09,s9
	namereg s0a,sa
	namereg s0b,sb
	namereg s0c,sc
	namereg s0d,sd
	namereg s0e,se
	namereg s0f,sf

	;register s0 contains device state/status info.
	;bit - function
	;0 - data to send (reserved, not actively used)
	;1 - write file flag (set when in 'wf' mode, receiving data to write to FIFO)
	;2 - read file flag (set when in 'rf' mode, reading data from FIFO to transmit)

	;register s1 contains input character counter
	;tracks the number of characters received in the command buffer (max ~128)

	;register s2 contains buffer pointer/index
	;used to navigate through the command buffer (base address 0x80) during parsing

	;register s3 contains ascii code of letter passed to 'send_letter'
	;general purpose register for character transmission
	
	;register s4 contains 1st char from char buffer, passed to 'ishex2digit'
	;ishex2digit returns a true/false flag in s4 indicating if both digits are valid hex

	;register s5 contains 2nd char from char buffer, passed to 'ishex2digit'
	;ishex2digit returns the combined hex byte value in s5 if both digits are valid hex

	;register s6 used by interrupt handlers
	;specifically used in check_CRLF to track CR detection for CRLF handling

	;register s7 used by UART receive interrupt handler
	;holds received character and various temporary values

	;register s8 used by UART and general temporary storage
	;holds status values and temporary calculations

	;register s9 used by UART FIFO operations
	;contains byte/word counter for FIFO read/write operations

	;registers sa, sb are used as general variables in various
	;jumps/subroutines

	;register sc is used in command parsing functions
	;holds character comparisons and temporary values

	;register sd is used in hex digit parsing functions
	;holds first hex digit value during conversion

	;register se is used in hex digit parsing and UART functions
	;holds second hex digit value and UART status checks

	;register sf contains binary mode flag for dump operations
	;0 = ASCII hex dump mode (default), 1 = binary dump mode

	;registers s10-s13 contain dump start address (32-bit)
	;s10 = addr[31:24], s11 = addr[23:16], s12 = addr[15:8], s13 = addr[7:0]

	;registers s14-s17 contain dump end address + 1 (32-bit)
	;s14 = addr[31:24], s15 = addr[23:16], s16 = addr[15:8], s17 = addr[7:0]
	;incremented by 1 to allow proper wrap detection

	;registers s18-s1b contain dump repeat counter (32-bit)
	;s18 = counter[31:24], s19 = counter[23:16], s1a = counter[15:8], s1b = counter[7:0]
	;counts down number of words to dump

	;registers s1c-s1f contain current dump address offset (32-bit)
	;s1c = addr[31:24], s1d = addr[23:16], s1e = addr[15:8], s1f = addr[7:0]
	;tracks current position during memory dump operation

	ADDRESS 000
	jump start
;	jump rx_rdy		;jump table for selecting interrupt
;	jump tx_done
;	jump noint
;	jump extint
;	jump noint
;	jump noint
;	jump noint
;	jump noint

	ADDRESS 009		;jump table for selecting control cmd
;	jump get_status
;	jump clr_fetr
;	jump noinstr
;	jump set_fetr
;	jump noinstr
;	jump set_addr
;	jump get_dscrip
;	jump noinstr
;	jump get_config
;	jump set_config		;0x09
;	jump noinstr		;0x0a
;	jump noinstr		;0x0b
;	jump noinstr		;0x0c	stops at addr 15h

	ADDRESS 016		;Vendor requests
;	jump write		;write memory location
;	jump read		;read memory location
;	jump capture		;capture data macro

	ADDRESS 020		;program can start after address 32d		

start:
    load s0, 00
	output s0,interrupt	;clear interrupt register
	call send_CRLF
	call send_prompt

	load s0,00		;initialize status register flags so interrupt will not see a file flag set
	load s1,00		;initialize character count

	enable interrupt


;registers used in main shouldn't be used anywhere else
;becuase interrupts are enabled
main:
	
	jump main




;########################### ISRs #################################
intrp:
;	input sa,interrupt	;get interrupt register
;	output sa,offset	;write interrupt register to offset
;	jump 000
	input sa,interrupt	;read interrupt register
	and sa,80		;unused
	jump nz,noint
	input sa,interrupt	;
	and sa,20		;unused
	jump nz,noint
	input sa,interrupt	;
	and sa,20		;unused
	jump nz,noint
	input sa,interrupt
	and sa,10		;unused
	jump nz,noint
	input sa,interrupt
	and sa,08		;check for external interrupt
	jump nz,extint
	input sa,interrupt
	and sa,04		;unused
	jump nz,noint
	input sa,interrupt
	and sa,02		;check for tx_done interrupt
	jump nz,tx_done
	input sa,interrupt
	and sa,01		;check for rx_rdy interrupt
	jump nz,rx_rdy
	jump noint


;==================================================================
; interrupt handler that puts incoming characters into a buffer
; and calls process_cmd if a CR is detected
; uses s1, s7, s8, s0
rx_rdy:
	input s7,UARTFIFO
	load s8,s0		;get status byte
	and s8,02		;check if write flag set
	jump z,regcmd
;	load s8,13		;base address for 32 bit fifo word
;	add s8,s9		;add index to base word
;	output s7,(s08)		;send received byte out
;	sub s9,01		;decrement word counter
;	jump nc,finish_intrp
;	load s9,03		;reset word counter
	output s7,18		;write 32 bit word to fifo
	add s9,00		;NOP
	add s9,00		;NOP
	input s8,17		;get fifo status
	and s8,20		;get full bit
	jump z,finish_intrp
	and s0,FD		;clear write flag
	call send_CRLF
	call send_prompt
	jump finish_intrp
regcmd:
	;load s8,s7		;store input byte
	;sub s7,0A      ;check for LF
    call check_CRLF
	jump nz,nocrdet		;no carriage return detected
    call process_cmd	;process received cmd
	load s1,00		;reset char cnt
	load s8,s0		;check for read/write flag
	and s8,06		;if flag don't send CR/LF and >>
	jump nz,no_crlf	;if not zero, flag set, don't send
    and sf,sf			  ; check for binary dump
    jump nz,no_crlf      ; skip CRLF and prompt if binary dump
	call send_CRLF
	call send_prompt
no_crlf:
    load sf,00      ;revert to normal prompt after dump
	jump finish_intrp
nocrdet:
	load s7,s8		;restore value
	sub s7,08		;check for backspace
	jump nz,nobsdet		;no backspace detected
	add s1,00		;get char cnt
	jump z,finish_intrp	;if char cnt = 0, nothing to backspace
	sub s1,01		;decrement char cnt
	call waitforfifo
	output s8,UARTFIFO
	jump finish_intrp
nobsdet:
	load s7,s8		;restore value
	sub s7,20		;check for chars below decimal 32
	jump nc,chargt19	;char above 19 which is in range
	jump finish_intrp	;return without doing anything
chargt19:
	load s7,s8		;restore value
	sub s7,7F		;check for chars above decimal 126
	jump c,charlt127	;char below 127 which is in range
	jump finish_intrp	;return without doing anything
charlt127:
	load s7,s1		;get char cnt
	add s7,80		;set to char buffer
	output s8,(s07)		;write char to buffer
	add s1,01		;increment character cnt
	call waitforfifo
	output s8,UARTFIFO
	jump finish_intrp


;==================================================================
tx_done:
	load s7,s0		;check for read file flag
	and s7,04
	jump z,finish_intrp
	call readword		;get byte and send out fifo
	jump finish_intrp


;==================================================================
extint:
	input s7,gpio1
	xor s7,ff
	output s7,gpio1
	or s0,04		;set bit 2 of s0, read file flag
	load s9,03		;reset word counter
	call readword		;get byte and send out fifo
	jump finish_intrp


;==================================================================
noint:
	jump finish_intrp


;###################### FUNcTIONS #################################
finish_intrp:	
    load sa,00
	output sa,interrupt	;clear interrupt register
	returni enable

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; process_cmd ---  uses s2,s4,s5,sc,sa
; parses commands and runs them
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
process_cmd:
	load s2,80		;set s2 to first char in buffer
	input sc,(s02)		;get character	
	sub sc,77		;check for 'w'
	jump nz,nowrdet
	add s2,01
	input sc,(s02)		;get character
	sub sc,72		;check for 'r'
	jump nz,nowrdet
	add s2,01
	input sc,(s02)
	sub sc,20		;check for 'space'
	jump nz,nowrdet
	add s2,01		;skip space

	;parse 8-bit address (variable length, max 2 hex digits)
	call parse_hex_var
	add s4,00		;check success
	jump z,nowrdet
	load sa,s13		;store address value (LSB only)

	;check for space separator
	input sc,(s02)
	sub sc,20		;check for 'space'
	jump nz,nowrdet
	add s2,01		;skip space

	;parse 8-bit data (variable length, max 2 hex digits)
	call parse_hex_var
	add s4,00		;check success
	jump z,nowrdet

	;check for LF
	input sc,(s02)
	sub sc,0A      ;check for LF
	jump nz,nowrdet
	output s13,(s0a)	;write data to port at address sa
	return
nowrdet:
	load s2,80		;set s2 to first char in buffer
	input sc,(s02)		;get character	
	sub sc,72		;check for 'r'
	jump nz,norddet
	add s2,01
	input sc,(s02)		;get character
	sub sc,64		;check for 'd'
	jump nz,norddet
	add s2,01
	input sc,(s02)
	sub sc,20		;check for 'space'
	jump nz,norddet
	add s2,01		;skip space

	;save buffer position for display later
	load sa,s2

	;parse 8-bit address (variable length, max 2 hex digits)
	call parse_hex_var
	add s4,00		;check success
	jump z,norddet

	;check for LF
	input sc,(s02)
	sub sc,0A      ;check for LF
	jump nz,norddet

	;display result
	call send_CRLF
	call send_addr
	;display address from buffer
	load s2,sa		;restore buffer position
rd_addr_loop:
	input s3,(s02)
	load sb,s3
	sub sb,20		;check for space
	jump z,rd_addr_done
	load sb,s3
	sub sb,0A		;check for LF
	jump z,rd_addr_done
	call send_letter
	add s2,01
	jump rd_addr_loop
rd_addr_done:
	load s3,20
	call send_letter
	load s3,3D
	call send_letter
	load s3,20
	call send_letter
	input s3,(s13)		;read from port at address in s13
	call send_s3		;send as hex
	return
norddet:
	load s2,80		;set s2 to first char in buffer
	input sc,(s02)		;get character	
	sub sc,77		;check for 'w'
	jump nz,nowfdet
	add s2,01
	input sc,(s02)		;get character
	sub sc,66		;check for 'f'
	jump nz,nowfdet
	add s2,01
	input sc,(s02)
	sub sc,0A      ;check for LF
	jump nz,nowfdet
	or s0,02		;set bit 1 of s0, write file flag
	load s9,03		;reset word counter
	return
nowfdet:
	load s2,80		;set s2 to first char in buffer
	input sc,(s02)		;get character	
	sub sc,72		;check for 'r'
	jump nz,norfdet
	add s2,01
	input sc,(s02)		;get character
	sub sc,66		;check for 'f'
	jump nz,norfdet
	add s2,01
	input sc,(s02)
	sub sc,0A      ;check for LF
	jump nz,norfdet
	or s0,04		;set bit 2 of s0, read file flag
	load s9,03		;reset word counter
	call readword
	return
norfdet:		
    ; sf contains 1 if binary or 0 if regular ascii hex dump
	load s2,80		;set s2 to first char in buffer
	input s4,(s02)		;get character	    
	sub s4,64		;check for 'd'
	jump z,dump_hex
	add s4,64		;restore after compare
	sub s4,62		;check for 'b'
	jump nz,noddet
    load sf,1       ; binary mode
dump_hex:
	add s2,01		;skip command char
	input sc,(s02)		;get next char
	sub sc,20		;check for 'space'
	jump nz,noddet
	add s2,01		;skip space

	;parse starting address (variable length)
	call parse_hex_var
	add s4,00		;check success
	jump z,noddet
	output s10,addr_3	;store address value
	output s11,addr_2
	output s12,addr_1
	output s13,addr_0
	;s10-s13 already contain start address for tracking

	;check for space separator
	input sc,(s02)
	sub sc,20		;check for 'space'
	jump nz,noddet
	add s2,01		;skip space

	;parse ending address (variable length)
	call parse_hex_var
	add s4,00		;check success
	jump z,noddet
	load s14,s10		;track ending address
	load s15,s11
	load s16,s12
	load s17,s13

	;check what comes next: space or LF
	input sc,(s02)
	sub sc,0A		;check for LF
	jump z,dump_default_repeat	;use default repeat of 1
	add sc,0A		;restore
	sub sc,20		;check for space
	jump nz,noddet		;neither space nor LF, error
	add s2,01		;skip space

	;parse repeat counter (variable length)
	call parse_hex_var
	add s4,00		;check success
	jump z,noddet
	load s18,s10		;track repeat counter
	load s19,s11
	load s1a,s12
	load s1b,s13

	;check for LF at end
	input sc,(s02)
	sub sc,0A		;check for LF
	jump nz,noddet
	jump dump_start_exec

dump_default_repeat:
	;set default repeat counter to 1
	load s18,00
	load s19,00
	load s1a,00
	load s1b,01
dump_start_exec:

    ; add one to final address to wrap correctly
	add s17,01            ; add one
    addcy s16,00          ; add with carry
    addcy s15,00          ; add with carry
    addcy s14,00          ; add with carry


first_addr:
    ; start at first address
    load s1f,s13
    load s1e,s12
    load s1d,s11
    load s1c,s10

	; loop and read all data
    ;read and send

count_down:
    ; if word counter is not zero, read data    
	sub s1b,00            ; noop
    jump z,borrow1        ; if 00, borrow from next higher byte counter
    jump decwordcount
borrow1:
	sub s1a,00            ; noop
    jump z,borrow2        ; if 00, borrow from next higher byte counter
    sub s1a,01            ; borrow 1
    jump decwordcount
borrow2:
	sub s19,00            ; noop
    jump z,borrow3        ; if 00, borrow from next higher byte counter
    sub s19,01            ; borrow 1
    sub s1a,01            ; borrow 1
    jump decwordcount
borrow3:
	sub s18,00            ; noop
    jump z,dumpdone       ; if 00, we're done, because we can't borrow.
    sub s18,01            ; borrow 1
    sub s19,01            ; borrow 1
    sub s1a,01            ; borrow 1
decwordcount:  
	sub s1b,01	          ; decrement word counter (subtract 1)    
	;jump count_down      

dump_word:

	output s1c,addr_3	;store address value
	output s1d,addr_2	;store address value
	output s1e,addr_1	;store address value
	output s1f,addr_0	;store address value
	;be sure to delay here before read

	; send CR LF
    and sf,sf			  ; check for zero
    jump nz,no_crlf_dump      ; skip CRLF if binary dump
	call send_CRLF
no_crlf_dump:
	
	input s3,data_3       ; actually do read
    call send_hex_or_letter        ; sends s3 as hex or letter depending on mode (sf=1 for binary)
	input s3,data_2       ; actually do read
    call send_hex_or_letter        ; sends s3 as hex or letter depending on mode
	input s3,data_1       ; actually do read
    call send_hex_or_letter        ; sends s3 as hex or letter depending on mode
	input s3,data_0       ; actually do read
    call send_hex_or_letter        ; sends s3 as hex or letter depending on mode
	;if address does not equal max
	;increment address and dump another word
count_up:
    ; if address is not zero, read data    
	add s1f,01            ; try to add one
    addcy s1e,00          ; add with carry
    addcy s1d,00          ; add with carry
    addcy s1c,00          ; add with carry

	; compare word to see if we should wrap
    ; use s3 as temporary storage
    load s3,s1f
    sub s3,s17
    jump nz,no_match
    load s3,s1e
    sub s3,s16
    jump nz,no_match
    load s3,s1d
    sub s3,s15
    jump nz,no_match
    load s3,s1c
    sub s3,s14
    jump nz,no_match

	; full match
    ; we will wrap when we restart the loop
    jump first_addr  ; check word counter and read another word

no_match:
    jump dump_word      ; no match, so read next word

    

dumpdone:
	return

noddet:		
	load s2,80		;set s2 to first char in buffer
	input sc,(s02)		;get character	
	sub sc,77		;check for 'w'
	jump nz,nowdet
	add s2,01
	input sc,(s02)	        ;get character
	sub sc,20		;check for 'space'
	jump nz,nowdet
	add s2,01		;skip space

	;parse address (variable length)
	call parse_hex_var
	add s4,00		;check success
	jump z,nowdet
	output s10,addr_3	;store address value
	output s11,addr_2
	output s12,addr_1
	output s13,addr_0

	;check for space separator
	input sc,(s02)
	sub sc,20		;check for 'space'
	jump nz,nowdet
	add s2,01		;skip space

	;parse data (variable length)
	call parse_hex_var
	add s4,00		;check success
	jump z,nowdet
	output s10,data_3	;store data bytes
	output s11,data_2
	output s12,data_1

	;check for LF
	input sc,(s02)
	sub sc,0A		;check for LF
	jump nz,nowdet
	output s13,data_0	;store last data byte (triggering actual write)
	return

nowdet:
	load s2,80		;set s2 to first char in buffer
	input sc,(s02)		;get character	
	sub sc,72		;check for 'r'
	jump nz,nordet
	add s2,01
	input sc,(s02)
	sub sc,20		;check for 'space'
	jump nz,nordet
	add s2,01		;skip space

	;save buffer position for display later
	load sa,s2

	;parse address (variable length)
	call parse_hex_var
	add s4,00		;check success
	jump z,nordet
	output s10,addr_3	;store address value
	output s11,addr_2
	output s12,addr_1
	output s13,addr_0	;triggers read

	;check for LF
	input sc,(s02)
	sub sc,0A		;check for LF
	jump nz,nordet

	;display result
	call send_CRLF
	call send_addr
	;display address from buffer
	load s2,sa		;restore buffer position
r_addr_loop:
	input s3,(s02)
	load sb,s3
	sub sb,20		;check for space
	jump z,r_addr_done
	load sb,s3
	sub sb,0A		;check for LF
	jump z,r_addr_done
	call send_letter
	add s2,01
	jump r_addr_loop
r_addr_done:
	load s3,20              ; (space)
	call send_letter
	load s3,3D              ; =
	call send_letter
	load s3,20              ; (space)
	call send_letter 

	input s3,data_3       ; actually do read
        call send_s3            ; sends s3 as hex
	input s3,data_2       ; actually do read
        call send_s3            ; sends s3 as hex
	input s3,data_1       ; actually do read
        call send_s3            ; sends s3 as hex
	input s3,data_0       ; actually do read
        call send_s3            ; sends s3 as hex
	return

nordet:
invalid_det:
	call send_CRLF
	call send_invalid
	return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; send_invalid ---  uses s3
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
send_invalid:
	load s3,69		; i
	call send_letter
	load s3,6E		; n
	call send_letter
	load s3,76		; v
	call send_letter
	load s3,61		; a
	call send_letter
	load s3,6C		; l
	call send_letter
	load s3,69		; i
	call send_letter
	load s3,64		; d
	call send_letter
	load s3,20		;
	call send_letter
	load s3,63		; c
	call send_letter
	load s3,6D		; m
	call send_letter
	load s3,64		; d
	call send_letter
	return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; send_addr ---  uses s3
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
send_addr:
	load s3,61		; a
	call send_letter
	load s3,64		; d
	call send_letter
	load s3,64		; d
	call send_letter
	load s3,72		; r
	call send_letter
	load s3,3A		; :
	call send_letter
	load s3,20		;
	call send_letter
	return	


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; send_prompt ---  uses s3
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
send_prompt:
	load s3,3E		; >
	call send_letter
	load s3,3E		; >
	call send_letter
	return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; send_CRLF ---  uses s3
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
send_CRLF:
	load s3,0D
	call send_letter
	load s3,0A
	call send_letter
	return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; check_CRLF ---  uses s2 as index into buffer
; reads input character from s7
; checks to see if CR or LF or CR+LF are received
; puts LF in buffer if any eol is detected
; sets z flag if any type of eol is found
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
check_CRLF:
	;if CR received, put LF in buffer
    ;if LF received, check if previous was CR and ignore 
    ;if previous was not CR, put LF in buffer.
    ;add s2,01       ; get next char
    
    load s8,s7		;store input byte
    sub s7,0D      ;check for CR
    jump nz,check_CRLF_nocrdet		;no carriage return detected
        ; if cr detected        
        call write_eol_to_buffer
        load s6, 01 ; flag to indicate CR detected, to help with CRLF detection
        jump check_CRLF_done   ; don't do else if or else
    check_CRLF_nocrdet:    
        ; else check for LF
        add s7,0D		;uncheck CR    
        sub s7,0A		;check for LF
        jump nz,check_CRLF_nolfdet		;no LF detected
            ; LF detected
            ; see if previous was CR                
            sub s6, 00  ;test for zero indicating previous character was not a cr            
            jump z,bare_LF_det
                ; CRLF detected, since LF was written for CR, don't write extra LF to buffer                
                ; this will return and swallow the extra LF
                jump bare_LF_end ; jump over else
            bare_LF_det:
                call write_eol_to_buffer
            bare_LF_end:
            jump check_CRLF_lf_done ; jump over else
        check_CRLF_nolfdet: ; neither CR nor LF character            
            ; do nothing.
            ; call write_eol_to_buffer
            ; end of else
        check_CRLF_lf_done:
        ; load doesn't clobber flags
        load s6, 00 ; save flag to indicate CR not detected, to help with next CRLF detection
    check_CRLF_done:
    load s7,s8		;restore value
	return

write_eol_to_buffer:
    ; write to buffer
    load s7,s1		;get char cnt
    add s7,80		;set to char buffer
    load s8,0A      ;load LF character
    output s8,(s07)		;write LF char to buffer
    sub s7,s7       ; zero flag indicates eol detected        
    return
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; send_hex_or_letter ---  uses s3,s4,sf
; sf contains 0 to send ascii hex, other to send letter as binary
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
send_hex_or_letter:
    and sf,sf		; test for zero
	call z,send_s3
	call nz,send_letter
	return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; send_letter ---  uses s3
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
send_letter:
	call waitforfifo
	output s3,UARTFIFO
	return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; send_s3 ---  uses s3,s4
; sends s3 as hex
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
send_s3:
	load s4,s3		;store value
	and s3,F0		;get rid of first 4 bits
	sr0 s3
	sr0 s3
	sr0 s3
	sr0 s3
	load sc,s3
	sub sc,0A		;check for alpha digit
	jump c,decdigit1a
	add s3,27
decdigit1a:
	add s3,30
	call send_letter
	load s3,s4		;restore
	and s3,0F		;get rid of last 4 bits
	load sc,s3
	sub sc,0A		;check for alpha digit
	jump c,decdigit2a
	add s3,27
decdigit2a:
	add s3,30
	call send_letter
	return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; waitforfifo ---  uses se
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
waitforfifo:
	input se,status		;get UART status
	and se,01		;clear all bits except LSB
	return z		;return if TX is idle
	jump waitforfifo	;otherwise wait for TX to finish


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ishex2digit ---  uses s4,s5,sd,se
; output in s5
; flag for valid in s4
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ishex2digit:
	load sd,s4		;store char
	sub sd,3A		;check if decimal
	jump nc,nodec1
	load sd,s4		;restore char
	sub sd,30		;check if decimal
	jump c,nodigit
	jump checkdigit2
nodec1:
	load sd,s4		;restore char
	sub sd,67		;check if alpha
	jump nc,nodigit
	load sd,s4		;restore char
	sub sd,61
	jump c,nodigit
	add sd,0A		;add 10 to sd
checkdigit2:
	load se,s5		;store char
	sub se,3A		;check if decimal
	jump nc,nodec2
	load se,s5		;restore char
	sub se,30		;check if decimal
	jump c,nodigit
	jump finishdigit
nodec2:
	load se,s5		;restore char
	sub se,67		;check if alpha
	jump nc,nodigit
	load se,s5		;restore char
	sub se,61
	jump c,nodigit
	add se,0A		;add 10 to se
finishdigit:
	sl0 sd
	sl0 sd
	sl0 sd
	sl0 sd			;shift sd 4 places to the right
	load s5,se
	add s5,sd		;add shifted # to s5
	load s4,01		;s4 --> 1 --> success
	return
nodigit:
	load s4,00
	return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; readword ---  uses s3,sd
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
readword:

	input s9,18			; read FIFO and get word size in bytes
	and s9,07			; clear other bits except for LSBs

fifonoread:
	add	s3,00
	add	s3,00
	add	s3,00
	add	s3,00

	sub s9,01			; decrement byte counter
	load sd,13			; load base address of memory
	add sd,s9			; relative address from base
	input s3,sd			; get byte
	call send_letter	; send byte out port

	add s9,00			; set flags
	jump nz,fifonoread	; if not zero read in another byte

	input sd,17			;get fifo status to check for empty
	and sd,10			;clear other bits
	return z
	and s0,FB			;clear read fifo flag
	return
	
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; parse_hex_var --- parses variable length hex string (1-8 hex chars)
; Input: s2 = buffer pointer (will be advanced)
; Output: s10-s13 = parsed 32-bit value (s10=MSB, s13=LSB)
;         s4 = success flag (1=success, 0=fail)
;         s2 = updated buffer pointer (after last hex digit)
; Uses: s2, s4, s5, s10, s11, s12, s13, sa, sb
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
parse_hex_var:
	load s10,00		;clear result registers
	load s11,00
	load s12,00
	load s13,00
	load sa,00		;digit counter
phv_loop:
	input s4,(s02)		;get character
	;check if space or LF (terminators)
	load sb,s4
	sub sb,20		;check for space
	jump z,phv_done
	load sb,s4
	sub sb,0A		;check for LF
	jump z,phv_done
	;check if valid hex digit
	load s5,s4		;duplicate for ishex1digit
	call ishex1digit	;check single hex digit
	add s4,00		;test success flag
	jump z,phv_fail		;not a hex digit, fail
	;shift existing value left by 4 bits
	load sb,s13		;get bits [3:0] of LSB
	and sb,F0
	sr0 sb
	sr0 sb
	sr0 sb
	sr0 sb			;shift to [7:4]
	sl0 s13			;shift s13 left
	sl0 s13
	sl0 s13
	sl0 s13
	or s12,sb		;move high bits into s12
	load sb,s12
	and sb,F0
	sr0 sb
	sr0 sb
	sr0 sb
	sr0 sb
	sl0 s12
	sl0 s12
	sl0 s12
	sl0 s12
	or s11,sb
	load sb,s11
	and sb,F0
	sr0 sb
	sr0 sb
	sr0 sb
	sr0 sb
	sl0 s11
	sl0 s11
	sl0 s11
	sl0 s11
	or s10,sb
	load sb,s10		;handle overflow
	sl0 sb
	sl0 sb
	sl0 sb
	sl0 sb
	;add new digit to LSB
	or s13,s5		;add new hex digit value
	add sa,01		;increment digit counter
	add s2,01		;advance buffer pointer
	load sb,sa
	sub sb,08		;check if we've read 8 digits
	jump z,phv_done		;max digits reached
	jump phv_loop
phv_done:
	load s4,01		;success
	return
phv_fail:
	load s4,00		;failure
	return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ishex1digit --- checks if single character is valid hex digit
; Input: s4 = character to check
; Output: s4 = success flag (1=valid, 0=invalid)
;         s5 = hex value (0-15) if valid
; Uses: s4, s5, sb
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ishex1digit:
	load s5,s4		;store char
	sub s5,30		;check if >= '0'
	jump c,ih1_notdigit
	load s5,s4
	sub s5,3A		;check if < ':'
	jump nc,ih1_checkalpha	;not 0-9, check A-F
	load s5,s4
	sub s5,30		;convert '0'-'9' to 0-9
	load s4,01		;success
	return
ih1_checkalpha:
	load s5,s4
	sub s5,41		;check if >= 'A'
	jump c,ih1_checklower
	load s5,s4
	sub s5,47		;check if < 'G'
	jump nc,ih1_checklower	;not A-F, check a-f
	load s5,s4
	sub s5,37		;convert 'A'-'F' to 10-15 (41-37=10)
	load s4,01		;success
	return
ih1_checklower:
	load s5,s4
	sub s5,61		;check if >= 'a'
	jump c,ih1_notdigit
	load s5,s4
	sub s5,67		;check if < 'g'
	jump nc,ih1_notdigit	;not a-f
	load s5,s4
	sub s5,57		;convert 'a'-'f' to 10-15 (61-57=10)
	load s4,01		;success
	return
ih1_notdigit:
	load s4,00		;failure
	return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ADDRESS 3FF
	jump intrp