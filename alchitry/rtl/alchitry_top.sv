/*
    This file was generated automatically by Alchitry Labs 2.0.41-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/
`default_nettype none // do not use implicit wire for port connections

`define C_NUM_QUADS 1
`define C_REFCLKS_USED 1

module alchitry_top #(
    parameter g_SIM = 1'b0,
    // parameter g_link_wait = 1'b1,
    parameter g_debug = 1'b0) (

      input wire clk, // 100 MHz
      input wire rst_n,
      output reg [7:0] led,
      input wire usb_rx,
      output reg usb_tx,
      input wire ft_clk,
      input wire ft_rxf,
      input wire ft_txe,
      inout wire [15:0] ft_data,
      inout wire [1:0] ft_be,
      output reg ft_rd,
      output reg ft_wr,
      output reg ft_oe,
      output reg ft_wakeup,
      output reg ft_reset,

      // GT top level ports
      //  output [(4*`C_NUM_QUADS)-1:0]		TXN_O,
      //  output [(4*`C_NUM_QUADS)-1:0]		TXP_O,
      //  input  [(4*`C_NUM_QUADS)-1:0]    	RXN_I,
      //  input  [(4*`C_NUM_QUADS)-1:0]   	RXP_I,
      //  input                           	SYSCLKP_I,

      // these must be removed if not used, to prevent this:
      //ERROR: [DRC UCIO-1] Unconstrained Logical Port: 2 out of 32 logical ports have no user assigned specific location constraint (LOC). This may cause I/O contention or incompatibility with the board power or connectivity affecting performance, signal integrity or in extreme cases cause damage to the device or the components to which it is connected. To correct this violation, specify all pin locations. This design will fail to generate a bitstream unless all logical ports have a user specified site LOC constraint defined.  To allow bitstream creation with unspecified pin locations (not recommended), use this command: set_property SEVERITY {Warning} [get_drc_checks UCIO-1].  NOTE: When using the Vivado Runs infrastructure (e.g. launch_runs Tcl command), add this command to a .tcl file and add that file as a pre-hook for write_bitstream step for the implementation run.  Problem ports: TXN_O, and TXP_O.

      //  output   wire                   TXN_O,
      //  output   wire                   TXP_O,
      input    wire                   RXN_I,  // these magically do not need a IOSTANDARD or PACKE_PIN constraint?
      input    wire                   RXP_I,
//      input    wire                   SYSCLKP_I, // 200MHz input from oscillator on board
//      input    wire                   SYSCLKN_I,
      //input    wire                   user_clk_p, // 128MHz input from synthesizer chip
      //input    wire                   user_clk_n,
      //input wire [`C_REFCLKS_USED-1:0] GTREFCLK0P_I, // 125MHz Unused
      //input wire [`C_REFCLKS_USED-1:0] GTREFCLK0N_I,
      input wire [`C_REFCLKS_USED-1:0] GTREFCLK1P_I, // 128MHz looped back via SMA cables
      input wire [`C_REFCLKS_USED-1:0] GTREFCLK1N_I,
      output  wire                    REC_CLOCK_P,
      output  wire                    REC_CLOCK_N
      // output USER_SMA_GPIO_P,
      // output USER_SMA_GPIO_N,
    //   output  wire                    USER_SMA_CLK_P,  // 128MHz output to loop back SMA
    //   output  wire                    USER_SMA_CLK_N
    //   output  wire                    SFP_CLK_SEL0,
    //   output  wire                    SFP_CLK_SEL1,
    //   output  wire                    SFP_CLK1_SEL0,
    //   output  wire                    SFP_CLK1_SEL1

    );
  logic rst;
  localparam _MP_STAGES_1420874663 = 3'h4;
  logic M_reset_cond_in;
  logic M_reset_cond_out;

  reset_conditioner #(
                      .STAGES(_MP_STAGES_1420874663)
                    ) reset_cond (
                      .clk(clk),
                      .in(M_reset_cond_in),
                      .out(M_reset_cond_out)
                    );


  localparam _MP_BUS_WIDTH_528252186 = 5'h10;
  localparam _MP_TX_BUFFER_528252186 = 12'h800;
  localparam _MP_RX_BUFFER_528252186 = 12'h800;
  localparam _MP_PRIORITY_528252186 = {{8'h52, 8'h58}};
  localparam _MP_PREEMPT_528252186 = 1'h0;
  logic M_ft_ft_rxf;
  logic M_ft_ft_txe;
  logic M_ft_ft_rd;
  logic M_ft_ft_wr;
  logic M_ft_ft_oe;
  logic [15:0] M_ft_ui_din;
  logic [1:0] M_ft_ui_din_be;
  logic M_ft_ui_din_valid;
  logic M_ft_ui_din_full;
  logic [15:0] M_ft_ui_dout;
  logic [1:0] M_ft_ui_dout_be;
  logic M_ft_ui_dout_empty;
  logic M_ft_ui_dout_get;

  ft #(
       .BUS_WIDTH(_MP_BUS_WIDTH_528252186),
       .TX_BUFFER(_MP_TX_BUFFER_528252186),
       .RX_BUFFER(_MP_RX_BUFFER_528252186),
       .PRIORITY(_MP_PRIORITY_528252186),
       .PREEMPT(_MP_PREEMPT_528252186)
     ) ft (
       .ft_clk(ft_clk),
       .ft_data(ft_data),
       .ft_be(ft_be),
       .clk(clk),
       .rst(rst),
       .ft_rxf(M_ft_ft_rxf),
       .ft_txe(M_ft_ft_txe),
       .ft_rd(M_ft_ft_rd),
       .ft_wr(M_ft_ft_wr),
       .ft_oe(M_ft_ft_oe),
       .ui_din(M_ft_ui_din),
       .ui_din_be(M_ft_ui_din_be),
       .ui_din_valid(M_ft_ui_din_valid),
       .ui_din_full(M_ft_ui_din_full),
       .ui_dout(M_ft_ui_dout),
       .ui_dout_be(M_ft_ui_dout_be),
       .ui_dout_empty(M_ft_ui_dout_empty),
       .ui_dout_get(M_ft_ui_dout_get)
     );


  always @* begin
    M_reset_cond_in = ~rst_n;
    rst = M_reset_cond_out;
    led = {ft_txe, ft_rxf, M_ft_ui_dout_empty, M_ft_ui_din_full};
    usb_tx = usb_rx;
    M_ft_ft_rxf = ft_rxf;
    M_ft_ft_txe = ft_txe;
    ft_rd = M_ft_ft_rd;
    ft_wr = M_ft_ft_wr;
    ft_oe = M_ft_ft_oe;
    ft_wakeup = 1'h1;
    ft_reset = !rst;
    M_ft_ui_dout_get = !M_ft_ui_din_full;
    M_ft_ui_din_valid = !M_ft_ui_dout_empty;
    M_ft_ui_din = M_ft_ui_dout;
    M_ft_ui_din_be = M_ft_ui_dout_be;
  end


  // add ac701 stuff

  // file: ibert_7series_gtp_0.v
  //////////////////////////////////////////////////////////////////////////////
  //
  // Reference example_ibert_7series_gtp_0 generated from IBERT IP
  //
  //
  // Take in fixed 200MHz SYSCLK and use as general perpose guaranteed clock
  // and also use it to create slower clock via mmcm to use for i2c module.
  //
  // Program si570 part over i2c to provide a configurable clock (128MHz) into
  // pins user_clk_p/n.
  //
  // Route the 128MHz clock from user_clk to rec_clock.. this rec_clock is then
  // routed on the board to the gtp refclk 0 via mux select lines SFP_CLK_SEL0/1.
  //
  //
  //////////////////////////////////////////////////////////////////////////////




  // define input/output wires explicitly to satisfy default_nettype none requirement and avoid a typo causing a silent mistake

  // cause the system to wait until the ethernet is ready before starting to send telemetry to the ethernet block
  wire                           g_link_wait;


  //
  // Ibert refclk internal signals
  //
  //   wire [`C_NUM_QUADS-1:0]    gtrefclk0_i;
  //   wire [`C_NUM_QUADS-1:0]    gtrefclk1_i;
  //   wire [`C_REFCLKS_USED-1:0] refclk0_i;
  //wire   [`C_REFCLKS_USED-1:0]      refclk1_i;
//  wire                       clk_200M;

//  wire                       i2c_done;

  //   wire [15:0]                _200MHz_SYSCLK_o; //200MHz
  //   wire [19:0]                _200MHz_SYSCLK; //200MHz
  //   wire [15:0]                _Si570_USER_CLK_o; //128MHz
  //   wire [15:0]                _GT_CLK_o; //128MHz
  //   wire [15:0]                _GT_CLK1_o; //128MHz
  //   wire [19:0]                _Si570_USER_CLK; //128MHz
  //   wire [19:0]                _GT_REF_CLK; //128MHz
  //   wire [19:0]                _GT_REF_CLK1; //128MHz

  //  wire clk_gt_128M;
  //  wire clk_gt1_128M;
  //   wire                       clk_gt0_odiv2;
  //wire                       clk_125M;
  wire                       clk_100M;
  wire                       clk_128M;
  //wire                       clk_20M;

//   wire                       i2c_rst;
//   reg                        vio_i2c_rst = 1'b0;

  //todo: hook to smi config?
//  reg                        eth_link_up = 1'b1;

  wire                       clk_wiz_locked;
  reg                        r_soft_reset_125M = 1'b0;
  reg                        r1_soft_reset_125M = 1'b0;
  reg                        r_clk_wiz_locked_128M = 1'b0;
  reg                        r1_clk_wiz_locked_128M = 1'b0;
  reg                        r_clk_wiz_locked_125M = 1'b0;
  reg                        r1_clk_wiz_locked_125M = 1'b0;
  reg                        r_clk_wiz_locked_256M = 1'b0;
  reg                        r1_clk_wiz_locked_256M = 1'b0;
  reg                        r_rst_128M = 1'b0;
  reg                        r_rst_256M = 1'b0;
//  reg                        r_rst_125M = 1'b0;

  wire                       clk_256M;
  //wire                       clk_25M;
  //   wire                       gt_data_valid;
  wire [31:0]                gt_data;
  wire [3:0]                 gt_data_is_k;
  wire [87:0]                packet_data;
  wire                       packet_valid;

  wire                       stream_clk0;
  wire                       stream_valid0;
  wire [31:0]                stream_enable0;
  wire [87:0]                stream_data0;


//   wire [7:0]                 eth_tdata;
//   wire                       eth_tvalid;
//   wire                       eth_tlast;
//   wire                       eth_tready;
//   wire [15:0]                eth_len;
//   wire [15:0]                eth_ip_id;
//   wire [15:0]                eth_udp_dest;
//   wire                       eth_telem_en;






  //   wire [31:0]                stream_ts0;


  //   wire                       sys_time_clk;
  //   wire                       rst_sys_time_clk;

  //reg                        r_rst_125M_telemetry = 1'b0;

//   wire                       gmii_tx_en;
//   wire [7:0]                 gmii_txd;

//   wire [3:0]                 rgmii_txd;
//   wire                       rgmii_tx_ctl;
//   wire                       rgmii_txc;

  wire                       gt_clk;

  // reset the packet counters
  reg reset_counters = 0;
  wire [31:0] total_packets;
  wire [31:0] mismatch_packets;

  wire                       okay_led;
  wire                       link_count_okay;
  wire                       gt_soft_reset;

  wire [47:0]                tx_mac_dest;



  // choose the mux input from si5324 device 0x1
//  assign SFP_CLK_SEL0 = 1'b1;
//  assign SFP_CLK_SEL1 = 1'b0;

  // choose SMA ref clock input 0x0
//  assign SFP_CLK1_SEL0 = 1'b0;
//  assign SFP_CLK1_SEL1 = 1'b0;

  // rename phy signals to match xilinx default xdc/schematic names
  
//  assign GPIO_LED_0 = okay_led;
//  assign GPIO_LED_1 = link_count_okay;


//  assign PHY_RESET_B = ~r_rst_125M;

  // drive constant output: not used
//  assign PHY_MDC = 1'b0;
  //   assign TXN_O = 1'b0;
  //   assign TXP_O = 1'b0;

  //    // not in use, but this goes here to prevent this warning:
  // WARNING: [Synth 8-3848] Net PHY_MDIO ... does not have driver.
  //assign PHY_MDIO = 1'bZ;




  parameter FREQ_CNT_VAL = 16'h0800;  //was 0x4000 for 200MHz clock, 0x800 for 25MHz


  //100Mhz to 128Mhz for serial link at 1.024 Gbps
  clk_wiz_100M clk_wiz_100M_i
               (
                 .clk_in1 (clk_100M),
                 .clk_out1 (clk_128M),
                 .locked (clk_wiz_locked)
               );

//   assign i2c_rst = vio_i2c_rst || ~clk_wiz_locked;
//   i2c_clk_cfg i2c_clk_cfg_i
//               (
//                 .clk  (clk_20M),
//                 .rst  (i2c_rst),
//                 .scl  (IIC_SCL_MAIN),
//                 .sda  (IIC_SDA_MAIN),
//                 .done (i2c_done)
//               );

  //   create reset in 128M clock domain

   always @(posedge clk_128M) begin
     r_clk_wiz_locked_128M <= clk_wiz_locked;
     r1_clk_wiz_locked_128M <= r_clk_wiz_locked_128M;

     if (r1_clk_wiz_locked_128M == 0)
       // reset until first MMCM is locked
       r_rst_128M <= 1;
     else
       r_rst_128M <= 0;
   end

//   always @(posedge clk_125M) begin
//     r_clk_wiz_locked_125M <= clk_wiz_locked;
//     r1_clk_wiz_locked_125M <= r_clk_wiz_locked_125M;

//     r_soft_reset_125M <= gt_soft_reset;
//     r1_soft_reset_125M <= r_soft_reset_125M;

//     if (r1_clk_wiz_locked_125M == 0)
//       // reset until first MMCM is locked
//       r_rst_125M <= 1;
//     else
//       r_rst_125M <= 0;
//   end

  always @(posedge clk_256M) begin
    r_clk_wiz_locked_256M <= clk_wiz_locked;
    r1_clk_wiz_locked_256M <= r_clk_wiz_locked_256M;

    if (r1_clk_wiz_locked_256M == 0)
      r_rst_256M <= 1;
    else
      r_rst_256M <= 0;
  end

  //
  // Sysclock IBUFDS instantiation
  //
//   IBUFGDS
//     #(.DIFF_TERM("FALSE"))
//     ibufgds_sysclk
//     (
//       .I(SYSCLKP_I),
//       .IB(SYSCLKN_I),
//       .O(clk_200M)
//     );

//   IBUFGDS
//     #(.DIFF_TERM("FALSE"))
//     ibufgds_userclk
//     (
//       .I(user_clk_p),
//       .IB(user_clk_n),
//       .O(user_clk)
//     );

   BUFG bufg_clk
        (
          .O(clk_100M),
          .I(clk)
        );

  OBUFDS #(
           .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
           .SLEW("FAST")           // Specify the output slew rate
         ) OBUFDS_REC_CLOCK (
           .O(REC_CLOCK_P),     // Diff_p output (connect directly to top-level port)
           .OB(REC_CLOCK_N),   // Diff_n output (connect directly to top-level port)
           .I(clk_128M)      // Buffer input
         );


  // generate user_CLOCK_N/P from Si570 programmable oscillator on board at 128M
  // route in fabric to output sma connectors.
  // sma back in on J23/H23 USER_CLOCK_N
//   OBUFDS #(
//            .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
//            .SLEW("FAST")           // Specify the output slew rate
//          ) OBUFDS_USER_SMA (
//            .O(USER_SMA_CLK_P),     // Diff_p output (connect directly to top-level port)
//            .OB(USER_SMA_CLK_N),   // Diff_n output (connect directly to top-level port)
//            .I(clk_128M)      // Buffer input
//          );

  // found in rtl/gt_support/gt_serial_telem_rx_subsystem.vhd
  gt_serial_telem_rx_subsystem gt_serial_telem_rx_subsystem
                               (
                                 .Q0_CLK1_GTREFCLK_PAD_N_IN  (GTREFCLK1N_I[0]),
                                 .Q0_CLK1_GTREFCLK_PAD_P_IN  (GTREFCLK1P_I[0]), // 128 reference in from mux on board from GTP SMA J25(p)/J26(N)
                                 .DRP_CLK_IN                 (clk_128M), // dynamic reconfiguration port routed from external sma because it can't be routed from the fabric.
                                 .RST_128M                 (r_rst_128M),
                                 .SOFT_RESET_OUT           (gt_soft_reset),
                                 .RXN_IN                      (RXN_I),
                                 .RXP_IN                      (RXP_I),

                                 .TXN_OUT                     (), // not used
                                 .TXP_OUT                     (),
                                 // this data comes out at the rxusrclk2 rate (32MHz)
                                 .data_clk_out (gt_clk),
                                 .data_out   (gt_data),
                                 .data_is_k_out (gt_data_is_k)
                               );




  // telemetry module
  // pulls in 32bit data and control
  // spits out packet data ready for ethernet
  // rtl/serial_link/gt_unpack_telemetry.vhd
  gt_unpack_telemetry gt_unpack_telemetry
                      (
                        .CLK_128M                 (clk_128M),
                        .RST_128M                 (r_rst_128M),
                        .gt_clk                   (gt_clk),
                        .gt_data                  (gt_data),
                        .gt_data_is_k             (gt_data_is_k),
                        .clk_256m_out (clk_256M),
                        .pll_locked_out (),
                        .okay_led_out (),
                        .cnt_led_out (),
                        // 11 byte outputs and control status signals, in clk_256M domain
                        .DATA_OUT                   (packet_data),
                        .VALID_OUT                     (packet_valid)
                      );


  telemetry_check telemetry_check
                  (
                    .clk_256M    (clk_256M),
                    .packet_data (packet_data),
                    .packet_valid (packet_valid),
                    .reset_counters (reset_counters),
                    .total_packets (total_packets),
                    .mismatch_packets (mismatch_packets),
                    .okay_led (okay_led),
                    .link_count_okay (link_count_okay)
                  );



  // we use records for telemetry module is this a problem with verilog?

  //-------------------------------------------------------------------------------
  //-- Ethernet Telemetry
  //-------------------------------------------------------------------------------

  // so add a a vhd wrapper to handle records/types into ethernet-telemetry
  // to work with .v


  // rtl/serial_link/ethernet_telemetry_subsystem
//   ethernet_telemetry_subsystem #()
//                                ethernet_telemetry_subsystem
//                                (
//                                  .eth_rst      (r_rst_125M_telemetry),
//                                  .eth_clk      (clk_125M),
//                                  .eth_tdata    (eth_tdata),
//                                  .eth_tvalid   (eth_tvalid),
//                                  .eth_tlast    (eth_tlast),
//                                  .eth_tready   (eth_tready),
//                                  .eth_len      (eth_len),
//                                  .eth_ip_id    (eth_ip_id),
//                                  .eth_udp_dest (eth_udp_dest),
//                                  .eth_telem_en (eth_telem_en),

//                                  .clk_128M      (clk_128M),
//                                  .clk_256M      (clk_256M),
//                                  .mobile_pkt_data(packet_data),
//                                  .mobile_pkt_data_val(packet_valid)
//                                );


  // data from tx

  assign g_link_wait = ~g_SIM; // don't wait in sim for the link to be ready because there is no hardware to wait for
  //always @(g_link_wait or eth_link_up)
  //  begin
  //     if (g_link_wait == 1)
  //assign eth_telem_en = (g_link_wait & eth_link_up) | (~g_link_wait);
  //     else
  //       eth_telem_en = 1;
  //  end



//   always @(posedge clk_125M) begin
//     //-- reset every time the link goes down
//     if (g_link_wait == 0) begin
//       //-- in sim, dummy this out to start right away.
//       r_rst_125M_telemetry <= r_rst_125M;
//     end
//     else begin
//       //-- on hardware, wait for the link to come up
//       //-- so that the fifo doesn't end up with partial
//       //-- data in it.
//       r_rst_125M_telemetry <= r_rst_125M | ~eth_link_up;
//     end

//   end




endmodule
`resetall
